generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  PRODUCER
  ADMIN
}

model User {
  id        String   @id @default(cuid()) // Using CUIDs for unique IDs
  email     String   @unique
  firstName String
  lastName  String
  password  String // This will store the hashed password, NOT the raw one.
  role      Role     @default(USER)
  points    Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pushToken  String? @unique
  isVerified Boolean @default(false)

  emailVerified     DateTime? // Guardará la fecha y hora de verificación. Si es null, no está verificado.
  verificationToken String?   @unique // Token único para la verificación

  // Relations
  profile  Profile?
  events   Event[]
  posts    Post[]
  comments Comment[]
  likes    Like[]

  Company           Company[]
  BenefitRedemption BenefitRedemption[]

  CommentLike        CommentLike[]
  channelMemberships ChannelMembership[]

  Order Order[]

  FavoriteEvent FavoriteEvent[]

  receivedFriendRequests Friendship[] @relation("receivedFriendRequests")
  sentFriendRequests     Friendship[] @relation("sentFriendRequests")

  conversations Conversation[]
  messagesSent  Message[]

  ClaimedBenefit ClaimedBenefit[]
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  DECLINED
  BLOCKED
}

model Friendship {
  requesterId String
  addresseeId String
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Relaciones
  requester User @relation("sentFriendRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  addressee User @relation("receivedFriendRequests", fields: [addresseeId], references: [id], onDelete: Cascade)

  @@id([requesterId, addresseeId])
  @@map("friendships")
}

model Profile {
  id String @id @default(cuid())

  bio         String?
  phone       String?
  nickname    String?
  avatarUrl   String?
  preferences Json?
  city        String?
  hometown    String?
  dateOfBirth DateTime?
  showInfo    Boolean   @default(false)

  // Info privada
  skills     String[]
  jobSeeking String?
  cvUrl      String?

  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// --- Event Models ---

model Event {
  id          String   @id @default(cuid())
  title       String
  description String
  date        DateTime
  address     String?
  city        String?
  latitude    Float
  longitude   Float
  imageUrls   String[]
  place       String?

  // --- RELACIONES CLAVE ---

  organizerId String
  organizer   User   @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  categories Category[]
  benefits   Benefit[]
  tickets    TicketType[]

  post Post[] // un evento puede tener múltiples posts asociados

  FavoriteEvent FavoriteEvent[]
}

model FavoriteEvent {
  userId    String
  eventId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@id([userId, eventId])
}

model TicketType {
  id           String @id @default(cuid())
  name         String // El nombre del tipo de entrada, ej: "Entrada General", "VIP", "Early Bird"
  priceInCents Int // El precio de este tipo de entrada en la moneda base (ej. USD)
  quantity     Int // La cantidad total de entradas de este tipo disponibles
  currency     String @default("usd")

  // Relación: Cada tipo de entrada pertenece a un evento específico
  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // Relación: Un tipo de entrada puede tener muchas entradas individuales vendidas
  tickets Ticket[]
}

enum TicketStatus {
  VALID // La entrada es válida y está lista para ser usada.
  USED // La entrada ya fue escaneada y utilizada.
  CANCELLED // La entrada fue cancelada (ej. por una devolución).
  EXPIRED // El evento ya pasó y la entrada no se usó.
}

model Ticket {
  id     String @id @default(cuid())
  qrCode String @unique

  // El estado actual de la entrada, para controlar su validez.
  status TicketStatus @default(VALID)

  // --- CAMPOS DE AUDITORÍA Y SEGURIDAD ---
  scannedAt          DateTime? // Hora exacta del escaneo.
  scannedByIp        String? // Dirección IP del dispositivo que realizó el escaneo.
  scannedByUserAgent String? // Información del navegador/OS del dispositivo que escaneó.

  // --- INFORMACIÓN DEL ASISTENTE (Opcional) ---
  attendeeName String?
  attendeeDni  String?

  // --- RELACIONES CLAVE ---

  // Relación con el tipo de entrada (ej. "VIP", "General Admission").
  // Esto nos permite saber qué se compró y a qué precio.
  ticketTypeId String
  ticketType   TicketType @relation(fields: [ticketTypeId], references: [id], onDelete: Cascade)

  // Relación con la orden de compra a la que pertenece.
  // Esto vincula la entrada con la transacción de pago y el comprador.
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

// 3. Un modelo para agrupar las entradas de una misma compra
model Order {
  id                    String @id @default(cuid())
  amount                Float // Monto total de la compra
  currency              String @default("usd")
  status                String // ej: "PENDING", "COMPLETED", "FAILED"
  stripePaymentIntentId String @unique // El ID del Payment Intent de Stripe

  userId String
  user   User   @relation(fields: [userId], references: [id])

  tickets   Ticket[]
  createdAt DateTime @default(now())
}

model Category {
  id   String @id @default(cuid())
  name String @unique

  // Relations
  events Event[] // Many-to-many relation with Event
  posts  Post[] // Many-to-many relation with Post (for tags)

  Benefit Benefit[] @relation("BenefitCategories")
}

// --- Community Feed Models ---

enum ChannelMembershipStatus {
  MEMBER
  PENDING // Para futuras solicitudes de acceso
  BLOCKED
}

model Channel {
  id          String  @id @default(cuid())
  name        String  @unique
  slug        String  @unique
  description String?
  iconName    String?
  isPrivate   Boolean @default(false)

  post    Post[]
  members ChannelMembership[]
}

model ChannelMembership {
  userId    String
  user      User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  channelId String
  channel   Channel                 @relation(fields: [channelId], references: [id], onDelete: Cascade)
  status    ChannelMembershipStatus @default(MEMBER)

  joinedAt DateTime @default(now())

  @@id([userId, channelId])
}

model Post {
  id        String   @id @default(cuid())
  content   String
  imageUrls String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  authorId String
  author   User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments Comment[] // One-to-many relation with Comment
  likes    Like[] // One-to-many relation with Like
  tags     Category[] // Many-to-many relation with Category (acting as tags)

  channelId String
  channel   Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  eventId String? // El post no siempre va a tener un evento asociado
  event   Event?   @relation(fields: [eventId], references: [id])
}

model Comment {
  id        String   @id @default(cuid())
  text      String
  createdAt DateTime @default(now())

  // Relations
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  postId   String
  post     Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  likes CommentLike[]
}

model CommentLike {
  userId    String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  commentId String
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  createAt DateTime @default(now())

  @@id([userId, commentId])
}

model Like {
  // This model doesn't need its own ID, as the combination of userId and postId is unique.
  createdAt DateTime @default(now())

  // Relations
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  // This ensures a user can only like a post once.
  @@id([userId, postId])
}

model Company {
  id          String  @id @default(cuid())
  name        String
  description String?
  logoUrl     String?
  city        String

  adminId String
  admin   User   @relation(fields: [adminId], references: [id])

  // La compañía ahora puede tener muchos eventos
  events   Event[]
  benefits Benefit[]
}

enum BenefitStatus {
  AVAILABLE
  EXPIRED
}

enum BenefitUsagePeriod {
  LIFETIME // N veces
  DAILY // Una vez por día
  WEEKLY // Una vez por semana
  MONTHLY // Una vez por mes
}

model Benefit {
  id          String        @id @default(cuid())
  title       String
  description String        @db.Text
  pointCost   Int           @default(0)
  expiresAt   DateTime?
  status      BenefitStatus @default(AVAILABLE) // AVAILABLE, EXPIRED, UNAVAILABLE

  // Reglas de uso
  usageLimit  Int                @default(1)
  limitPeriod BenefitUsagePeriod @default(LIFETIME)

  companyId String
  company   Company @relation(fields: [companyId], references: [id])

  categories Category[] @relation("BenefitCategories")
  events     Event[]

  redemptions BenefitRedemption[]

  claimedBy ClaimedBenefit[] // Lista de usuarios que lo han reclamado
}

model BenefitRedemption {
  id         String    @id @default(cuid())
  token      String    @unique // El token de un solo uso
  expiresAt  DateTime // Cuándo expira el token
  redeemedAt DateTime? // Cuándo fue canjeado

  userId String
  user   User   @relation(fields: [userId], references: [id])

  benefitId String
  benefit   Benefit @relation(fields: [benefitId], references: [id], onDelete: Cascade)

  // Relación uno a uno: un canje pertenece a un único beneficio reclamado.
  claimedBenefitId String?         @unique
  claimedBenefit   ClaimedBenefit? @relation(fields: [claimedBenefitId], references: [id])
}

model ClaimedBenefit {
  id        String               @id @default(cuid())
  createdAt DateTime             @default(now())
  status    ClaimedBenefitStatus @default(AVAILABLE) // AVAILABLE, USED, EXPIRED
  userId    String
  user      User                 @relation(fields: [userId], references: [id])
  benefitId String
  benefit   Benefit              @relation(fields: [benefitId], references: [id], onDelete: Cascade)

  // Un beneficio reclamado solo puede tener UN intento de canje (un QR) a la vez.
  redemption BenefitRedemption?
}

enum ClaimedBenefitStatus {
  AVAILABLE
  USED
  EXPIRED
  REDEEMED
}

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relación con los usuarios que participan en la conversación
  participants User[]

  // Relación con los mensajes de esta conversación
  messages Message[]

  @@map("conversations")
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
}

model Message {
  id        String        @id @default(cuid())
  createdAt DateTime      @default(now())
  text      String?       @db.Text
  type      String        @default("TEXT")
  status    MessageStatus @default(SENT)
  senderId  String
  sender    User          @relation(fields: [senderId], references: [id], onDelete: Cascade)

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@map("messages")
}
